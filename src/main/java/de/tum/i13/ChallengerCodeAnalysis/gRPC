public class ChallengerServer extends ChallengerImplBase {
    private final ArrayBlockingQueue<ToVerify> dbInserter;
    private final IQueries q;
    private final int durationEvaluationMinutes;
    private final Random random;
    final private ConcurrentHashMap<Long, BenchmarkState> benchmark;
    private IDataStore store;

    public ChallengerServer(IDataStore store, ArrayBlockingQueue<ToVerify> dbInserter, IQueries q, int durationEvaluationMinutes) {
        this.store = store;
        this.dbInserter = dbInserter;
        this.q = q;
        this.durationEvaluationMinutes = durationEvaluationMinutes;
        benchmark = new ConcurrentHashMap<>();
        random = new Random(System.nanoTime());
    }
    @Override
    public void createNewBenchmark(BenchmarkConfiguration request, StreamObserver<Benchmark> responseObserver) {
        String token = request.getToken();
        try {
            if (!q.checkIfGroupExists(token)) {
                Status status = Status.FAILED_PRECONDITION.withDescription("token invalid");
                responseObserver.onError(status.asException());
//                responseObserver.onCompleted();
                return;
            }
        } catch (SQLException | ClassNotFoundException | InterruptedException throwables) {
            errorCounter.inc();
            Status status = Status.INTERNAL.withDescription("database offline - plz. inform the challenge organizers");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        if (request.getQueriesList().size() < 1) {
            Status status = Status.FAILED_PRECONDITION.withDescription("no query selected");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        if (!isValid(request.getBenchmarkType())) {
            Status status = Status.FAILED_PRECONDITION.withDescription("unsupported benchmarkType");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        BenchmarkType bt = BenchmarkType.Test;
        int batchSize = 1_000;
        if (request.getBenchmarkType().equalsIgnoreCase("test")) {
            bt = BenchmarkType.Test;
            batchSize = 1_000;
        } else if (request.getBenchmarkType().equalsIgnoreCase("verification")) {
            bt = BenchmarkType.Verification;
        } else if (request.getBenchmarkType().equalsIgnoreCase("evaluation")) {
            bt = BenchmarkType.Evaluation;
            batchSize = 1_000;
        }
        String benchmarkName = request.getBenchmarkName();
        long benchmarkId = Math.abs(random.nextLong());
        try {
            UUID groupId = q.getGroupIdFromToken(token);
            q.insertBenchmarkStarted(benchmarkId, groupId, benchmarkName, batchSize, bt);
        } catch (SQLException | ClassNotFoundException | InterruptedException throwables) {
            Status status = Status.INTERNAL.withDescription("plz. inform the challenge organisers - database not reachable");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        BenchmarkState bms = new BenchmarkState(this.dbInserter);
        bms.setToken(token);
        bms.setBenchmarkId(benchmarkId);
        bms.setToken(token);
        bms.setBenchmarkType(bt);
        bms.setBenchmarkName(benchmarkName);
        bms.setQ1(request.getQueriesList().contains(Query.Q1));
        bms.setQ2(request.getQueriesList().contains(Query.Q2));
        Instant stopTime = Instant.now().plus(durationEvaluationMinutes, ChronoUnit.MINUTES);
        if (bt == BenchmarkType.Evaluation) {
            var bi = new BatchIterator(this.store, stopTime);
            bms.setDatasource(bi);
        } else {
            // for the time being, there is no difference in the dataset
            var bi = new BatchIterator(this.store, stopTime);
            bms.setDatasource(bi);
        }
        this.benchmark.put(benchmarkId, bms);
        Benchmark bm = Benchmark.newBuilder()
                .setId(benchmarkId)
                .build();
        responseObserver.onNext(bm);
        responseObserver.onCompleted();
    }
    static final Counter startBenchmarkCounter = Counter.build()
            .name("startBenchmark")
            .help("calls to startBenchmark methods")
            .register();
    @Override
    public void startBenchmark(Benchmark request, StreamObserver<Empty> responseObserver) {
        if (!this.benchmark.containsKey(request.getId())) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not created");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        this.benchmark.computeIfPresent(request.getId(), (k, b) -> {
            b.setIsStarted(true);
            b.startBenchmark(System.nanoTime());
            return b;
        });
        responseObserver.onNext(Empty.newBuilder().build());
        responseObserver.onCompleted();
    }
    @Override
    public void nextBatch(Benchmark request, StreamObserver<Batch> responseObserver) {
        if (!this.benchmark.containsKey(request.getId())) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not created");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        if (!this.benchmark.get(request.getId()).getIsStarted()) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not started, call startBenchmark first");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        AtomicReference<Batch> batchRef = new AtomicReference<>();
        this.benchmark.computeIfPresent(request.getId(), (k, b) -> {
            try {
                if (b.getBenchmarkType() == BenchmarkType.Evaluation) { //this comes from memory and is too fast
                    batchRef.set(b.getNextBatch(request.getId()));
                    nextBatchValidation.inc();
                } else {
                    Histogram.Timer batchReadTimer = batchReadLatency.startTimer();

                    batchRef.set(b.getNextBatch(request.getId()));

                    batchReadTimer.observeDuration();
                    nextBatchTest.inc();
                }
            } catch (InvalidProtocolBufferException e) {
                e.printStackTrace();
                Status status = Status.INTERNAL.withDescription("Could not get next batch, plz. let the DEBS challenge organizers know that they should fix this bug, .. IMMEDIATELY. thanks!");
                responseObserver.onError(status.asException());
//                responseObserver.onCompleted();
            } catch (RocksDBException e) {
                e.printStackTrace();
                Status status = Status.INTERNAL.withDescription("Could not get next batch, plz. let the DEBS challenge organizers know that they should fix this bug, .. IMMEDIATELY. thanks!");
                responseObserver.onError(status.asException());
//                responseObserver.onCompleted();
            } catch (InterruptedException e) {
                e.printStackTrace();
                Status status = Status.INTERNAL.withDescription("Could not get next batch, plz. let the DEBS challenge organizers know that they should fix this bug, .. IMMEDIATELY. thanks!");
                responseObserver.onError(status.asException());
//                responseObserver.onCompleted();
            }
            return b;
        });
        Batch acquired_batch = batchRef.getAcquire();
        if (acquired_batch == null) {
            Status status = Status.INTERNAL.withDescription("Could not get next batch");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        } else {
            responseObserver.onNext(acquired_batch);
            responseObserver.onCompleted();
        }
    }
    @Override
    public void resultQ1(ResultQ1 request, StreamObserver<Empty> responseObserver) {
//        System.out.println("q1"+request);
        long nanoTime = System.nanoTime();
        if (!this.benchmark.containsKey(request.getBenchmarkId())) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not created");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        if (!this.benchmark.get(request.getBenchmarkId()).getIsStarted()) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not started, call startBenchmark first");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        this.benchmark.computeIfPresent(request.getBenchmarkId(), (k, b) -> {
            b.resultsQ1(request, nanoTime);
            return b;
        });
        responseObserver.onNext(Empty.newBuilder().build());
        responseObserver.onCompleted();
    }
    @Override
    public void resultQ2(ResultQ2 request, StreamObserver<Empty> responseObserver) {
        long nanoTime = System.nanoTime();
        if (!this.benchmark.containsKey(request.getBenchmarkId())) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not started");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        if (!this.benchmark.get(request.getBenchmarkId()).getIsStarted()) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not started, call startBenchmark first");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        this.benchmark.computeIfPresent(request.getBenchmarkId(), (k, b) -> {
            b.resultsQ2(request, nanoTime);
            return b;
        });
        responseObserver.onNext(Empty.newBuilder().build());
        responseObserver.onCompleted();
    }
    @Override
    public void endBenchmark(Benchmark request, StreamObserver<Empty> responseObserver) {
        long nanoTime = System.nanoTime();
        if (!this.benchmark.containsKey(request.getId())) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not started");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        if (!this.benchmark.get(request.getId()).getIsStarted()) {
            Status status = Status.FAILED_PRECONDITION.withDescription("Benchmark not started, call startBenchmark first");
            responseObserver.onError(status.asException());
//            responseObserver.onCompleted();
            return;
        }
        AtomicBoolean found = new AtomicBoolean(false);
        this.benchmark.computeIfPresent(request.getId(), (k, b) -> {
            b.endBenchmark(request.getId(), nanoTime);
            found.set(true);
            return b;
        });
        if (found.get()) {
            this.benchmark.remove(request.getId());
        }
        responseObserver.onNext(Empty.newBuilder().build());
        responseObserver.onCompleted();
        endBenchmarkCounter.inc();
    }
}